---
title: "Fetching FIA data for sugarbush growth models"
author: "Neal Maker"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  pdf_document:
    fig_caption: TRUE
    df_print: kable
---

```{r, setup, include=FALSE}
# knitr::opts_chunk$set(echo = T, error = T, warning = T, message = T,
#                       strip.white = F, tidy.opts = list(width.cutoff = 60))
knitr::opts_chunk$set(echo = FALSE, error = FALSE, warning = FALSE,
                      message = FALSE)
```

# Introduction

Here I pull together a dataset of remeasured trees from the US Forest Service's Forest Inventory and Analysis (FIA) records for the Northern Forest region, which will allow us to build sugarbush tree growth, mortality, and ingrowth models. It will be filtered to only include subplots with sufficient sugar maple stocking such that they could be viable sugarbushes. We would like to have at least 3 measurements for each subplot (they're remeasured about every 5 years) but also would like to only use data that was collected using the current standard plot design, which was created in the mid 1990s. We'll see if there's enough data after those requirements are met. The 3 measurements will allow us to build an ingrowth/regeneration model that accounts for logging removals that were made ahead of time. (As in, we see how much basal area was removed from year 0 to year 5, which will become a predictor for ingrowth that happens between years 5 and 10.) The models will be fairly simple, with species, dbh, bal, and previous logging removals as the only predictors.

The Northern Forest region was chosen because it covers a fairly large geographic extent while still representing a coherent ecological region, in which trees can be expected to follow a similar set of behaviors. Models developed with the dataset should be relatively unbiased for individual sugarbushes within the region, while still being trained on enough data (we hope) to paint an accurate picture. The US Northern Forest is defined here as including Oswego, Oneida, Lewis, Jefferson, Saint Lawrence, Herkimer, Fulton, Hamilton, Franklin, Essex, Clinton, and Warren Counties in New York; Franklin, Orleans, Essex, Chittenden, Lamoille, Caledonia, Washington, Addison, Orange, and Grand Isle Counties in Vermont; Coos, Grafton, and Carroll Counties in New Hampshire; and Oxford, Franklin, Somerset, Androscoggin, Kennebec, Waldo, Hancock, Washington, Penobscot, Piscataquis, and Aroostook Counties in Maine.

```{r region}
library("dplyr")
library("lubridate")
library("english")

# Define States & counties (FIPS codes) in Northern Forest region --------

states <- c("NY", "VT", "NH", "ME")

NY_counties <- c(75, 65, 49, 45, 89, 43, 35, 41, 33, 31, 19, 113)
VT_counties <- c(11, 19, 9, 7, 15, 5, 23, 1, 17, 13)
NH_counties <- c(7, 9, 3)
ME_counties <- c(17, 7, 25, 1, 11, 27, 9, 29, 19, 21, 3)
```

# Methods

FIA data are downloaded from the FIA DataMart^[https://apps.fs.usda.gov/fia/datamart/datamart.html] in the form of state-specific csv files, which were generated by the Forest Service from the FIA Oracle database tables. These data are current as of `r format(Sys.Date(), format = "%B %d, %Y")`.

```{r fetch}
################################################################################
# Import FIA data
################################################################################

# Fetch FIA tree, growth, plot, & condition data for Northern Forest states
# and filter to keep only northern forest counties
# (this may take a while; ~140MB of downloads + reading)

temp <- tempfile()

for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/",
                      state, "_TREE.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_TREE.csv", sep = ""))
}

TREE <- lapply(states, function(x){
  read.csv(paste(x, "_TREE.csv", sep = ""), header = T) %>%
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = ""))),
           DIAHTCD == 1) %>% # excludes seedlings measured at root collar
    select(CN, PLT_CN, SUBP, PREV_TRE_CN, CONDID, DIA, SPCD, STATUSCD) %>%
    mutate(ba_ac = if_else(DIA >= 5,
                           # poles & larger from 24' radius subplots
                           # saplings from 6.8' radius microplots
                           0.005454*DIA^2*(43560/(pi*24^2)),  
                           0.005454*DIA^2*(43560/(pi*6.8^2))))
})

## SUBPLOTS MATTER!!!!
# Subplots may have different sizes depending on the plot design, found in
# PLOT$DESIGNCD (see database guide, appendix i)
# I can just keep DESIGNCD == 1 (the main standard) and lose some data,
# or I can account for the various designs when I calculate TREE$ba_ac
# (above; which would mean calculating ba_ac after combining
# states' data and joining nf_trees to nf_plots).
# Update: it's probably harder b/c they severed the plot codes to older
# inventories to keep people from seeing real coordinates

# DESIGN CODES:
# 1:4 used 1999 - present
# 11:15 used 1994 - 1996
# 100 used 1982 & 1983
# 101:104 used 1991 - 1998
# 101 was continued through 2008
# 105:120 variousy used 1991 - 1993


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state,
                      "_PLOT.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_PLOT.csv", sep = ""))
}

PLOT <- lapply(states, function(x){
  read.csv(paste(x, "_PLOT.csv", sep = ""), header = T) %>%
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = "")))) %>%
    select(CN, PREV_PLT_CN, DESIGNCD, MEASYEAR, MEASMON,
           MEASDAY, LAT, LON, ELEV) %>%
    rename(PLT_CN = CN)
})


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state,
                      "_COND.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_COND.csv", sep = ""))
}

COND <- lapply(states, function(x){
  read.csv(paste(x, "_COND.csv", sep = ""), header = T) %>%
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = "")))) %>%
    select(PLT_CN, CONDID, FORTYPCD, ALSTKCD, SITECLCD,
           PHYSCLCD, SLOPE, ASPECT)
})


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state,
                      "_TREE_GRM_COMPONENT.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_TREE_GRM_COMPONENT.csv", sep = ""))
}

GRM <- lapply(states, function(x){
  read.csv(paste(x, "_TREE_GRM_COMPONENT.csv", sep = ""), header = T) %>%
    select(TRE_CN, STATECD, DIA_BEGIN, DIA_MIDPT, DIA_END,
           ANN_DIA_GROWTH, ANN_HT_GROWTH)
})

# Combine states' data

nf_trees <- do.call(rbind, TREE)
nf_plots <- do.call(rbind, PLOT)
nf_conds <- do.call(rbind, COND)
nf_grms <- do.call(rbind, GRM)

# delete temporary objects and downloaded files

unlink(temp)

remove(TREE, PLOT, COND, GRM, temp, state)

for(state in states){
  file.remove(paste(state, "_TREE.csv", sep = ""))
  file.remove(paste(state, "_PLOT.csv", sep = ""))
  file.remove(paste(state, "_COND.csv", sep = ""))
  file.remove(paste(state, "_TREE_GRM_COMPONENT.csv", sep = ""))
}
```

Records for individual trees were joined to plot and condition data to add site and stand attributes, and data from remeasured plots were joined to data from previous inventories to add repeated measurements. Records for trees without remeasurement data were discarded, along with records for trees that were already dead at their starting measurement, trees that were incorrectly inventoried during starting or ending inventories, and seedlings with diameters measured at the root collar instead of at breast height. FIA plot designs varied in the past in different years and locations, and we only used inventories that employed the current, standard plot design. This design started being used in the mid 1990s, and allows easy comparison between inventories from different times and places.



```{r bal}
################################################################################
# Group species
################################################################################

# Make names and factor levels more intuitive ------------------------------

species_codes <-
  c(12, 43, 68, 70, 71, 91, 94, 95, 96, 97, 105, 123, 125, 126, 129,
    130, 136, 202, 221, 241, 261, 310, 313, 314, 315, 316, 317, 318,
    319, 320, 331, 341, 355, 356, 357, 367, 370, 371, 372, 373, 375,
    379, 391, 400, 402, 403, 407, 409, 421, 462, 491, 500, 531, 540,
    541, 543, 544, 546, 552, 601, 602, 621, 651, 655, 660, 661, 663,
    680, 693, 701, 712, 731, 741, 742, 743, 744, 746, 760, 761, 762,
    763, 764, 771, 802, 804, 806, 816, 823, 832, 833, 837, 901, 920,
    922, 923, 926, 934, 935, 936, 937, 950, 951, 970, 972, 975, 977,
    999)

species <-
  c("fir", "other softwood", "cedar", "tamarack", "tamarack",
    "norway spruce", "white spruce", "other softwood", 
    "other softwood", "red spruce", "other softwood", "other softwood",
    "red pine", "other softwood", "white pine", 
    
    "scots pine", "other softwood", "other softwood", "other softwood",
    "cedar", "hemlock", "other hardwood", "other hardwood", 
    "hard maple", "striped maple", "red maple", "silver maple", 
    "hard maple", 
    
    "shrubs", "hard maple", "other hardwood", "other hardwood",
    "shrubs", "shrubs", "shrubs", "other hardwood", "other hardwood", 
    "yellow birch", "other hardwood", "other hardwood", "paper birch", 
    
    "gray birch", "shrubs", "hickory", "hickory", "hickory", "hickory",
    "hickory", "other hardwood", "other hardwood", "shrubs", "shrubs",
    "beech", "ash", 
    
    "ash", "black ash", "ash", "ash", "other hardwood", "butternut",
    "other hardwood", "other hardwood", "other hardwood", 
    "other hardwood", "apple", "apple", "apple", 
    
    "other hardwood", "other hardwood", "hophornbeam", 
    "other hardwood", "other hardwood", "aspen", "cottonwood", "aspen",
    "cottonwood", "aspen", "shrubs", "pin cherry", "black cherry", 
   
    "shrubs", "shrubs", "shrubs", "white oak", "white oak", "red oak",
    "white oak", "white oak", "white oak", "red oak", "red oak", 
    "other hardwood", "shrubs", 
    
    "black willow", "shrubs", "shrubs", "shrubs", "shrubs", "shrubs", 
    "shrubs", "basswood", "basswood", "elm", "elm", "elm", "elm", 
    
    "other hardwood")

names(species) <- as.character(species_codes)

nf_trees$SPCD <- factor(unname(species[as.character(nf_trees$SPCD)]),
                     levels = levels(factor(species))) # standardize levels


################################################################################
# Calculate BAL & plot BA for each tree
################################################################################

# Calculates overtopping basal area (BAL) assuming all input trees are in
# same plot and ba is adjusted based on tpa:
pbal <- function(dbh, ba){
  sapply(dbh, function(x){
    index <- dbh > x
    return(sum(ba[index]))
  })
}


# Add BAL
nf_trees <- nf_trees %>%
  mutate(bal = NA,
         ba = NA)

# Note that this only calculates ending basal areas for trees that lived
nf_trees[nf_trees$STATUSCD == 1,] <- nf_trees[nf_trees$STATUSCD == 1,] %>%
  group_by(PLT_CN, SUBP) %>%
  mutate(bal = pbal(DIA, ba_ac),
         ba = sum(ba_ac, na.rm = T)) %>%
  ungroup()
```

Some of the variables retained from the FIA tables were recorded in the field, while others were determined remotely by the FIA Program. I also calculate plot basal area and tree overtopping basal area here after the fact, by grouping trees into their respective plots and subplots.

```{r before_and_after}
################################################################################
# Combine FIA tables & reformat
################################################################################

# make ending data, which will be used to find data from earlier measurements of the same subplots (but note that this can contain multiple measurements from the same subplot; for a plot that's been measured 4 times, we'll get three different 'records at the end...)

nf_end <- nf_trees %>%
  left_join(nf_plots, by = "PLT_CN") %>%
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  rename(cn_e = CN,
         cn_pu_from_e = PREV_TRE_CN,
         plt_cn_e = PLT_CN,
         plt_cn_pu_from_e = PREV_PLT_CN,
         subp_e = SUBP,
         condid_e = CONDID,
         spp_e = SPCD,
         dbh_e = DIA,
         statuscd_e = STATUSCD,
         MEASYEAR_E = MEASYEAR,
         MEASMON_E = MEASMON,
         MEASDAY_E = MEASDAY,
         ba1_e = ba,
         bal1_e = bal,
         forest_type_e = FORTYPCD,
         stocking_e = ALSTKCD,
         site_class_e = SITECLCD,
         landscape_e = PHYSCLCD,
         slope_e = SLOPE,
         aspect_e = ASPECT,
         designcd_e = DESIGNCD) %>% 
  select(-LAT, -LON, -ELEV) %>% # we'll just use starting values
  filter(!is.na(plt_cn_pu_from_e)) # remove those that weren't already measured

# now need data from next-to last measurement
nf_penultimate <- nf_trees %>%
  left_join(nf_plots, by = "PLT_CN") %>%
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  filter(PLT_CN %in% nf_end$plt_cn_pu_from_e) %>% 
  rename(cn_pu = CN,
         cn_s_from_pu = PREV_TRE_CN,
         plt_cn_pu = PLT_CN,
         plt_cn_s_from_pu = PREV_PLT_CN,
         subp_pu = SUBP,
         condid_pu = CONDID,
         spp_pu = SPCD,
         dbh_pu = DIA,
         statuscd_pu = STATUSCD,
         MEASYEAR_pu = MEASYEAR,
         MEASMON_pu = MEASMON,
         MEASDAY_pu = MEASDAY,
         ba1_pu = ba,
         bal1_pu = bal,
         forest_type_pu = FORTYPCD,
         stocking_pu = ALSTKCD,
         site_class_pu = SITECLCD,
         landscape_pu = PHYSCLCD,
         slope_pu = SLOPE,
         aspect_pu = ASPECT,
         designcd_pu = DESIGNCD) %>% 
  select(-LAT, -LON, -ELEV) %>% # we'll just use starting values
  filter(!is.na(plt_cn_s_from_pu)) # remove those that weren't already measured

# ...and data from third-to-last measurement (starting data)
nf_start <- nf_trees %>%
  left_join(nf_plots, by = "PLT_CN") %>%
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  filter(PLT_CN %in% nf_penultimate$plt_cn_s_from_pu) %>% 
  rename(cn_s = CN,
         plt_cn_s = PLT_CN,
         subp_s = SUBP,
         condid_s = CONDID,
         spp_s = SPCD,
         dbh_s = DIA,
         statuscd_s = STATUSCD,
         MEASYEAR_s = MEASYEAR,
         MEASMON_s = MEASMON,
         MEASDAY_s = MEASDAY,
         ba1_s = ba,
         bal1_s = bal,
         forest_type_s = FORTYPCD,
         stocking_s = ALSTKCD,
         site_class_s = SITECLCD,
         landscape_s = PHYSCLCD,
         slope_s = SLOPE,
         aspect_s = ASPECT,
         designcd_s = DESIGNCD)

###### I've worked through up to here #############################################
###################################################################################



nf_fia <- nf_end %>%
  left_join(nf_start, by = c("PREV_TRE_CN" = "cn_s")) %>%
  filter(statuscd_s == 1, # only trees that started live
         statuscd_e != 0, # remove trees that were remeasured incorrectly
         #cr_s >= 0,       # only trees that had cr at start
         designcd_s == 1, # only those with current plot design
         designcd_e == 1) %>%   
  mutate(MEASMON_E = formatC(MEASMON_E, width = 2, format = "d", flag = "0"),
         MEASMON_S = formatC(MEASMON_S, width = 2, format = "d", flag = "0"),
         MEASDAY_E = formatC(MEASDAY_E, width = 2, format = "d", flag = "0"),
         MEASDAY_S = formatC(MEASDAY_S, width = 2, format = "d", flag = "0"),
         #make month and day codes 2 digits
         date_s = ymd(paste0(MEASYEAR_S, MEASMON_S, MEASDAY_S)),
         date_e = ymd(paste0(MEASYEAR_E, MEASMON_E, MEASDAY_E))) %>%
  # remove incorrectly entered dates (eg. Feb 31)
  filter(!is.na(date_e), !is.na(date_s)) %>%
  mutate(interval = as.double(as.period(date_e - date_s), unit = "years"),
         cr_rate = (cr_e - cr_s)/interval,
         cr_mid = (cr_e + cr_s)/2,
         dbh_rate = (dbh_e - dbh_s)/interval,
         dbh_mid = (dbh_e + dbh_s)/2,
         spp_rich_mid = (spp_rich_e + spp_rich_s)/2,
         dbh_var_mid = (dbh_var_e + dbh_var_s)/2,
         ht_var_mid = (ht_var_e + ht_var_s)/2,
         ba1_mid = (ba1_e + ba1_s)/2,
         bal1_mid = (bal1_e + bal1_s)/2,
         psi1_mid = (psi1_e + psi1_s)/2,
         ht_mid = (ht_e + ht_s)/2,
         ht_rate = (ht_e - ht_s)/interval,
         status_change = case_when(statuscd_e == 1 ~ "lived",
                                   statuscd_e == 2 ~ "died",
                                   statuscd_e == 3 ~ "cut",
                                   TRUE ~ "error"),
         status_change = as.factor(status_change),
         SPCD = as.factor(SPCD),
         plt_cn_e = as.factor(plt_cn_e)) %>%
  rename(ba1_ac = ba_ac) %>%
  select(cn_e, spp = SPCD, dbh_e, dbh_rate, cr_s, cr_mid,
         cr_e, cr_rate, crown_class_s, crown_class_e, tree_class_s,
         tree_class_e, spp_rich_s, spp_rich_mid, spp_rich_e, dbh_var_s, 
         dbh_var_mid, dbh_var_e, ht_var_s, ht_var_mid, ht_var_e, ba1_s, 
         ba1_mid, ba1_e, bal1_s, bal1_mid, bal1_e, 
         psi1_s, psi1_mid, psi1_e, ht_s, ht_mid, ht_e, ht_rate,
         forest_type_s, forest_type_e, stocking_s, stocking_e,
         landscape_s, landscape_e, site_class_s, site_class_e,
         slope_s, slope_e, aspect_s, aspect_e, lat = LAT, lon = LON,
         elev = ELEV, date_s, date_e, interval, status_change,
         plot = plt_cn_e, ba1_ac, plt_cn_s, SUBP,
         starts_with("ba_"), starts_with("bal_"), starts_with("psi_")) %>%
  # mortality year was all null and was removed
  inner_join(nf_grms, by = c("cn_e" = "TRE_CN")) %>%
  # use these dbh's b/c inconsistencies have been resolved (eg. measurements at different heights)
  rename(dbh_s = DIA_BEGIN, dbh_mid = DIA_MIDPT,
         dbh_rate_fia = ANN_DIA_GROWTH, state = STATECD) %>% 
  select(-ANN_HT_GROWTH)


remove(nf_start, nf_end, nf_conds, nf_plots, nf_trees, nf_grms, states,
       VT_counties, NH_counties, NY_counties, ME_counties, pbal, state,
       sppba, sppbal, temp, species, species_codes, sbal)
```

Starting and ending values were retained for variables that naturally change from one measurement to another, and midpoint values were calculated for some variables by averaging the starting and ending values. Midpoint values were recorded to better reflect average conditions during the remeasurement period.

Some of the ostensibly fixed variables like slope, aspect, and site class were found to change from one measurement to another in a minority of instances. For example, aspect was recorded differently in `r ifelse(round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia)) >= 10,round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, slope was recorded differently in `r ifelse(round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia)) >= 10, round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, and site class was recorded differently in `r ifelse(round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia)) >= 10, round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, despite the fact that they were measured on the same plots and should have remained constant. The differences between starting and ending values are generally small, however, and are probably measurement errors. In the case of slope, the mean absolute difference of deviating measurements is only `r ifelse(round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T)))` percent. Among erroneous site class measures, the average is only `r ifelse(round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T)))` site class.  Aspect errors tend to be higher, averaging `r ifelse(round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T)) >= 10, round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T)), english::words(round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T))))` degrees, but they can be attributed to the difficulty of determining aspects in relatively flat terrain.  If only plots with slopes over 20 percent are considered, the mean absolute aspect error falls to `r ifelse(round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T)))` degrees. All these discontinuities were assumed to be random measurement errors, and starting values were arbitrarily retained in the dataset while ending values were discarded.

```{r fixed_vars}
# Keep starting values for fixed variables & ------------------------------
# only keep records with all necessary fields ----------------------------

nf_fia <- nf_fia %>%
  rename(landscape = landscape_s,
         site_class = site_class_s,
         slope = slope_s,
         aspect = aspect_s) %>%
  select(-landscape_e, -site_class_e, -slope_e, -aspect_e)
```

Variables in the dataset were renamed and FIA codes for the levels of categorical variables were replaced with descriptive strings, to make them more intuitive and user-friendly. Tree species were also grouped into species groups and FIA forest types into more general forest types; so they match common inventory protocols and to facilitate the incorporation of uncommon species and forest types into growth models. For example, most species in the genus *Populus* are combined into a single "aspen" group, although cottonwoods (*Populus deltoides*) are kept in their own group because they exhibit very different growth characteristics. Similarly, the FIA forest types "balsam fir", "white spruce", "red spruce", "red spruce/balsam fir", and "black spruce" were combined into a single "Spruce-fir" group, but "northern white-cedar" was kept in its own "Cedar" group.

```{r categorical_levels}
################################################################################
# Make names and factor levels more intuitive
################################################################################

# Forest types -----------------------------------------------------------------

forest_type_codes <-
  c(101, 102, 103, 104, 105, 121, 122, 123, 124, 125, 126, 127,
    167, 171, 381, 384, 385, 401, 402, 409, 503, 505, 509, 512,
    513, 515, 516, 517, 519, 520, 701, 702, 703, 704, 705, 706,
    707, 708, 709, 801, 802, 805, 809, 901, 902, 903, 904, 905,
    962, 995, 999)

forest_types <-
  c("Red pine", "Red pine", "White pine", "Mixed softwood", "Hemlock",
    "Spruce-fir", "Spruce-fir", "Spruce-fir", "Spruce-fir", "Spruce-fir",
    "Larch", "Cedar", "Mixed softwood", "Mixed softwood", "Scots pine",
    "Norway spruce", "Larch", "Pine-hardwood", "Mixedwood",
    "Pine-hardwood", "Oak-hickory", "Oak-hickory", "Oak-hickory",
    "Transition hardwood", "Transition hardwood", "Oak-hickory",
    "Transition hardwood", "Transition hardwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Transition hardwood",
    "Cottonwood", "Other", "Other", "Other", "Northern hardwood",
    "Northern hardwood", "Cottonwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Northern hardwood",
    "Northern hardwood", "Northern hardwood", "Other", "Other",
    "Nonstocked")

names(forest_types) <- as.character(forest_type_codes)

nf_fia$forest_type_s <-
  factor(unname(forest_types[as.character(nf_fia$forest_type_s)]),
         levels = levels(factor(forest_types)))

nf_fia$forest_type_e <-
  factor(unname(forest_types[as.character(nf_fia$forest_type_e)]),
         levels = levels(factor(forest_types)))

# Landscapes -------------------------------------------------------------------

landscape_codes <- # add 19 & 33
  c(11, 12, 13, 19, 21, 22, 23, 24, 25, 29, 31, 32, 33, 34, 39)

landscapes <-
  c("dry tops", "dry slopes", "deep sands", "other xeric", "flatwoods",
    "rolling uplands", "moist slopes & coves", "narrow floodplains/bottomlands",
    "broad floodplains/bottomlands", "other mesic", "swamps/bogs",
    "small drains", "small drains", "beaver ponds", "other hydric")

names(landscapes) <- as.character(landscape_codes)

nf_fia$landscape <- factor(unname(landscapes[as.character(nf_fia$landscape)]),
                           levels = levels(factor(landscapes)))
```

# Missing Values

Examination of the data showed that some `r round(100 * (sum(is.na(nf_fia)) / (ncol(nf_fia) * nrow(nf_fia))), 1)`% of the values were missing. The missing values were associated with only a fraction of the variables, depicted in the following table.

```{r na}
vars_na <- 
  data.frame(variable = names(nf_fia),  
             n_NA = colSums(is.na(nf_fia)),
             pct_NA = round(colMeans(is.na(nf_fia))*100, 2),
             row.names = NULL) %>% 
  arrange(desc(n_NA)) %>% 
  filter(n_NA > 0) 

knitr::kable(vars_na, col.names = c("Variable", "Missing", "% Missing"))
```

Most of these missing values are associated with porous sail indexes and heights. The FIA program only records heights on a random subset of observations, and the porous sail index can only be calculated on plots in which all live trees have height measurements. So while these missing values limit the amount of data available for training growth models, they are random omissions and should not introduce bias. 

Many of the remaining missing values are mid-interval or end-of-interval values that are missing because the trees died. Across all the data, `r sum(nf_fia$status_change != "lived")` trees died during the remeasurement interval, and these correspond perfectly with the mid-interval and end-of-interval bal missing values. Mid-interval and end-of-interval crown ratio values are also missing for all trees that died, though they are also missing for a small number of trees that lived. End-of-interval dbh values are missing for many of the trees that died, but are present for some of them because they were estimated from stump diameters by the FIA program.

A small number of observations are missing values for other variables too, like ending forest types and stocking, and these appear to be random recording errors that can be safely removed without introducing bias.

```{r save}
################################################################################
# Finish up
################################################################################

nf_fia <- nf_fia %>% 
  filter(!is.na(spp), # only keep records with all neccessary fields
         !is.na(dbh_s), # these could affect some trees in a plot, but not all.
         !is.na(cr_s),
         !is.na(crown_class_s),
         !is.na(tree_class_s),
         !is.na(ba1_s),
         !is.na(bal1_s),
         !is.na(forest_type_s),
         !is.na(forest_type_e),
         !is.na(stocking_s),
         !is.na(stocking_e),
         !is.na(landscape),
         !is.na(site_class),
         !is.na(slope),
         !is.na(aspect),
         !is.na(lat),
         !is.na(lon),
         !is.na(elev),
         !is.na(status_change),
         xor(is.na(bal1_e), status_change == "lived"))

remove(forest_type_codes, forest_types, landscape_codes, landscapes)

# put columns in order
nf_fia <- nf_fia %>%
  select(spp, dbh_s, dbh_mid, dbh_e, dbh_rate, dbh_rate_fia, cr_s, cr_mid,
         cr_e, cr_rate, crown_class_s, crown_class_e, tree_class_s,
         tree_class_e, spp_rich_s, spp_rich_mid, spp_rich_e, dbh_var_s,
         dbh_var_mid, dbh_var_e, ht_var_s, ht_var_mid, ht_var_e, ba1_s, 
         ba1_mid, ba1_e, bal1_s, bal1_mid, bal1_e, psi1_s, psi1_mid, psi1_e, 
         ht_s, ht_mid, ht_e, ht_rate, forest_type_s, forest_type_e,
         stocking_s, stocking_e, landscape, site_class, slope, aspect,
         lat, lon, elev, state, date_s, date_e, interval, status_change,
         plot, ba1_ac, plt_cn_s, SUBP,
         starts_with("ba_"), starts_with("bal_"), starts_with("psi_")) %>%
  rename(ba_s = ba1_s, ba_mid = ba1_mid, ba_e = ba1_e,
         bal_s = bal1_s, bal_mid = bal1_mid, bal_e = bal1_e,
         psi_s = psi1_s, psi_mid = psi1_mid, psi_e = psi1_e,
         ba_ac = ba1_ac)


# Save ---------------------------------------------------------------------

save(nf_fia, file = "../data/nf-fia.rda")
```

# Organization

The final dataset contains `r format(nrow(nf_fia),big.mark=",")` unique tree records, which were tallied across `r format(length(unique(nf_fia$plot)),big.mark=",")` plots evenly distributed throughout the region. Tallied trees belong to `r length(unique(nf_fia$spp))` different species groups and were located in `r length(unique(c(nf_fia$forest_type_s,nf_fia$forest_type_e)))` different forest types in `r length(unique(nf_fia$landscape))` different physiographic (landscape) positions. Remeasurement periods ranged from `r round(min(nf_fia$interval),2)` to `r round(max(nf_fia$interval),2)` years and averaged `r round(mean(nf_fia$interval),2)` years. `r english::Words(round(100*nrow(dplyr::filter(nf_fia,status_change=="lived"))/nrow(nf_fia)))` percent of tallied trees lived through the remeasurement period and the remaining `r english::words(round(100*nrow(dplyr::filter(nf_fia,status_change=="died" | status_change=="cut"))/nrow(nf_fia)))` percent died.

A description of each variable in the final dataset and its source is provided below. Fields from the FIA database are referenced by their Oracle table and field names, in the form $TABLE\$FIELD$. Some of the variables account for more than one column in the dataset. Variable names amended with $\_s$ are measurements taken at the start of the remeasurement period; those amended with $\_e$ are measurements taken at the end of the remeasurement period; those amended with $\_mid$ are estimates of mid-period values, calculated by averaging the starting and ending measurements; and those amended with $\_rate$ are annual rates of change, averaged over the remeasurement period. Positive rates are increasing values, and negative rates are decreasing values.

__spp__   
\vspace{2pt}
Species or species group. Adapted from $TREE\$SPCD$.

__dbh__   
\vspace{2pt}
Diameter at breast height (4.5' above ground), measured in inches. From $TREE\$DIA$. Note that $dbh\_rate$ is calculated as $(dbh\_e - dbh\_s) / interval$ and is the preferred variable for model formulation. $dbh\_rate\_fia$ is from $TREE\_GRM\_COMPONENT\$ANN\_DIA\_GROWTH$ and is estimated using an existing diameter growth model. It is included for reference only and should not be used to train new models.

__cr__   
\vspace{2pt}
Compacted crown ratio (percent of tree height supporting live crown). From $TREE\$CR$.

__crown_class__   
\vspace{2pt}
Tree canopy position. From $TREE\$CCLCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*1* Open grown (crown has received full light for most or all of its life)   
&nbsp;&nbsp;&nbsp;&nbsp;*2* Dominant (crown extends above main canopy and receives full light from above and partly from sides)   
&nbsp;&nbsp;&nbsp;&nbsp;*3* Codominant (crown in main canopy and receives full light from above, but little from sides)  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Intermediate (crown extends into main canopy, but receives little direct light)    
&nbsp;&nbsp;&nbsp;&nbsp;*5* Overtopped (crown entirely below main canopy level, receiving no direct light)  

__tree_class__   
\vspace{2pt}
General quality of a live tree. From $TREE\$TREECLCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*2* Growing-stock (of commercial species and meeting minimum merchantability standards)  
&nbsp;&nbsp;&nbsp;&nbsp;*3* Rough-cull (sound wood, but does not meet minimum merchantability standards)  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Rotten-cull (does not meet minimum merchantability standards and more than half of cull is rotten)  

__spp_rich__   
\vspace{2pt}
Subplot species richness, calculated as the total number of unique species occurring on each subplot.

__dbh_var__   
\vspace{2pt}
Coefficient of variation of trees' diameters at breast height within each subplot, used as a measure of structural diversity. Calculated by dividing the standard deviation of diameters by their mean. 

__ht_var__   
\vspace{2pt}
Coefficient of variation of trees' heights within each subplot, used as a measure of structural diversity. Calculated by dividing the standard deviation of heights by their mean. 

__ba__  
\vspace{2pt}
Plot basal area, measured in square feet per acre of all live trees, 1" dbh or greater. Calculated by computing individual trees' per acre basal areas ($ba * tpa$), then summing those basal areas within subplots. Variables whose names end with a species name (such as $ba\_ash$) are plot basal areas of only the species indicated.

__bal__   
\vspace{2pt}
Overtopping basal area, measured in square feet per acre. Calculated by computing individual trees' per acre basal areas ($ba * tpa$), then for each tree summing the per acre basal areas of other trees in in the same subplot with larger diameters. Variables whose names end with a species name (such as $bal\_ash$) are overtopping basal areas that only account for overtopping trees of the species indicated.

__psi__   
\vspace{2pt}
Porous sail index, whose computation is described in the 'Methods' section above. Variables whose names end with a species name (such as $psi\_ash$) are porous sail indexes that only account for trees of the species indicated.

__ht__   
\vspace{2pt}
Total tree height, measured in feet. From $TREE\$HT$. For trees with broken tops, heights are estimated by FIA program.

__forest_type__   
\vspace{2pt}
Forest type defined by the species dominating stocking. Adapted from $COND\$FORTYPCD$. Note that FIA does not recognize a "mixedwood" forest type, so plots with greater than half of their basal area in softwood species are generally considered softwood types, and those with greater than half of their stocking in hardwoods are considered hardwood types. The exceptions are the "Pine-hardwood" and "Cedar-hardwood" types. The forest types used here do not always coincide well with available stocking charts. Types in the Northern Forest region include:   
&nbsp;&nbsp;&nbsp;&nbsp;*Northern hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Transition hardwood*    
&nbsp;&nbsp;&nbsp;&nbsp;*Oak-hickory*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cottonwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Pine-hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cedar-hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Spruce-fir*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cedar*  
&nbsp;&nbsp;&nbsp;&nbsp;*Hemlock*  
&nbsp;&nbsp;&nbsp;&nbsp;*Larch* (includes tamarack)  
&nbsp;&nbsp;&nbsp;&nbsp;*Norway spruce*  
&nbsp;&nbsp;&nbsp;&nbsp;*White pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Red pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Scots pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Mixed softwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Other*  
&nbsp;&nbsp;&nbsp;&nbsp;*Nonstocked*  

__stocking__  
\vspace{2pt}
Plot-level stocking of all live trees 1" dbh and larger. From $COND\$ALSTKCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*1* Overstocked   
&nbsp;&nbsp;&nbsp;&nbsp;*2* Fully stocked   
&nbsp;&nbsp;&nbsp;&nbsp;*3* Medium stocked  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Poorly stocked    
&nbsp;&nbsp;&nbsp;&nbsp;*5* Nonstocked   

__landscape__  
\vspace{2pt}
Physiography. From $COND\$PHYSCLCD$. Depends on land form, topographic position, and soil type.  Classes include:   
&nbsp;&nbsp;&nbsp;&nbsp;*dry tops*  
&nbsp;&nbsp;&nbsp;&nbsp;*dry slopes*  
&nbsp;&nbsp;&nbsp;&nbsp;*deep sands*  
&nbsp;&nbsp;&nbsp;&nbsp;*other xeric*  
&nbsp;&nbsp;&nbsp;&nbsp;*flatwoods*  
&nbsp;&nbsp;&nbsp;&nbsp;*rolling uplands*  
&nbsp;&nbsp;&nbsp;&nbsp;*moist slopes & coves*  
&nbsp;&nbsp;&nbsp;&nbsp;*narrow floodplains/bottomlands*  
&nbsp;&nbsp;&nbsp;&nbsp;*broad floodplains/bottomlands*  
&nbsp;&nbsp;&nbsp;&nbsp;*other mesic*  
&nbsp;&nbsp;&nbsp;&nbsp;*swamps/bogs*  
&nbsp;&nbsp;&nbsp;&nbsp;*small drains*  
&nbsp;&nbsp;&nbsp;&nbsp;*beaver ponds*  
&nbsp;&nbsp;&nbsp;&nbsp;*other hydric*  

__site_class__  
\vspace{2pt}
Site productivity class. From $COND\$SITECLCD$. Defined by potential wood growth in cubic feet per acre per year:   
&nbsp;&nbsp;&nbsp;&nbsp;*1* 225+ ft^3^ac^-1^yr^-1^  
&nbsp;&nbsp;&nbsp;&nbsp;*2* 165-224 ft^3^ac^-1^yr^-1^   
&nbsp;&nbsp;&nbsp;&nbsp;*3* 120-164 ft^3^ac^-1^yr^-1^   
&nbsp;&nbsp;&nbsp;&nbsp;*4* 85-119 ft^3^ac^-1^yr^-1^ (equivalent to class I in VT)     
&nbsp;&nbsp;&nbsp;&nbsp;*5* 50-84 ft^3^ac^-1^yr^-1^ (equivalent to class II in VT)  
&nbsp;&nbsp;&nbsp;&nbsp;*6* 20-49 ft^3^ac^-1^yr^-1^ (equivalent to class III in VT)     
&nbsp;&nbsp;&nbsp;&nbsp;*7* 0-19 ft^3^ac^-1^yr^-1^ (equivalent to class IV in VT)  

__slope__  
\vspace{2pt}
Slope in percent. From $COND\$SLOPE$.

__aspect__  
\vspace{2pt}
Aspect in degrees. From $COND\$ASPECT$.

__lat__  
\vspace{2pt}
Plot latitude in decimal degrees (random offset is applied to protect landowners' privacy). From $PLOT\$LAT$.

__lon__  
\vspace{2pt}
Plot longitude in decimal degrees (random offset is applied to protect landowners' privacy). From $PLOT\$LON$.

__elev__  
\vspace{2pt}
Plot elevation in feet above mean sea level. From $PLOT\$ELEV$.

__date__  
\vspace{2pt}
Inventory date. Calculated from $PLOT\$MEASYEAR$, $PLOT\$MEASMON$, and $PLOT\$MEASDAY$.

__interval__  
\vspace{2pt}
Length of remeasurement period in years. Calculated as $date\_e - date\_s$.

__status_change__  
\vspace{2pt}
Change in tree status during remeasurement period. Based on $TREE\$STATUSCD$. One of:   
&nbsp;&nbsp;&nbsp;&nbsp;*lived*  
&nbsp;&nbsp;&nbsp;&nbsp;*died* (natural mortality)  
&nbsp;&nbsp;&nbsp;&nbsp;*cut*  

__plot__  
\vspace{2pt}
A unique identifier for the plot the tree was recorded on. Corresponds to $PLOT\$CN$ attribute for the ending inventory.
